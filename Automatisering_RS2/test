import source.filbehandling.make_objects as mo
import numpy as np
import re

# mellom 45 +- 8.1302+++->, vinkel der ting føkkes opp
vinkel = -135
forflytning_x = 0
forflytning_y = 0
mektighet = 8

x_lim = [-150, 150]
y_lim = [-150, 150]

path_of_RS2_file = r"C:\Users\Eirik\OneDrive\Documents\10. Prosjekt og masteroppgave\modellering_svakhetssone\parameterstudie\Mine modeller\RS2\tverrsnitt_sirkulær\arbeidsfiler\S_bm80_ss1_k1_od100_m2\rs2\S_bm80_ss1_k1_od100_m2_v20_y0_x0\S_bm80_ss1_k1_od100_m2_v20_y0_x0.fea"
path_of_RS2_file = mo.alternate_slash([path_of_RS2_file])[0]

with open(path_of_RS2_file, 'r') as file:
    # read a list of lines into data
    data = file.readlines()
index_materialMesh = data.index("materials mesh start:\n")+4
index_boundary1 = data.index("  boundary 1 start:\n")+6


points_tunnel_boundary = data[45753:46117].copy()
# making list of tupples cons
for index, points in enumerate(points_tunnel_boundary):
    data[index_boundary1+index] = re.sub(r'^(\s*(?:\S+\s+){0})\S+', r'\1 ' + str(index)+':', data[index_boundary1+index])
    points_string = re.findall(r"[-+]?(?:\d*\.\d+|\d+\b(?!:))", points)
    points = (float(points_string[0]), float(points_string[1]))
    points_tunnel_boundary[index] = points

fourth_quad = points_tunnel_boundary[0:91]
first_quad = points_tunnel_boundary[91:182]
second_quad = points_tunnel_boundary[182:273]
third_quad = points_tunnel_boundary[273:364]
quad = (fourth_quad, first_quad, second_quad, third_quad)

# mektighet, legges til før forflytning og rotasjon, og endrer kun y-verdi siden sonen i utgangspunktet er horisontal

x_venstre = -np.sqrt(5 ** 2 - (mektighet/2) ** 2) + forflytning_x
x_hoyre = np.sqrt(5 ** 2 - (mektighet/2) ** 2) + forflytning_x
y_topp = mektighet/2 + forflytning_y
y_bunn = -mektighet/2 + forflytning_y

theta = np.deg2rad(vinkel)
rot_matr = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])
punkt_bunn_hoyre = np.dot(rot_matr, np.array([x_hoyre, y_bunn]))
punkt_topp_hoyre = np.dot(rot_matr, np.array([x_hoyre, y_topp]))
punkt_topp_venstre = np.dot(rot_matr, np.array([x_venstre, y_topp]))
punkt_bunn_venstre = np.dot(rot_matr, np.array([x_venstre, y_bunn]))

punkter_indre = [punkt_bunn_hoyre, punkt_topp_hoyre, punkt_topp_venstre, punkt_bunn_venstre]

#ytre grense:
def find_points_on_outer_boundary(point_r, point_l):
    point_r = np.array(point_r)
    point_l = np.array(point_l)
    test = [150, -150]
    a = (point_r[1] - point_l[1])/(point_r[0] - point_l[0])
    b = point_r[1]-a*point_r[0]
    point = []
    # finder hvilken begrensning som gjelder for de to punkter som beskriver linja og lagrer den ferdige beskrivelsen i en vector
    for i in range(2):
        y = a * test[i] + b
        x = (test[i]-b)/a
        if abs(y) <= 150:
            point.append(np.array([test[i], y]))
        if abs(x) <= 150:
            point.append(np.array([x, test[i]]))
# sørger for at det endrede punkt til høyre er lagret i første element av vektoren
    v = np.sqrt(np.dot(np.linalg.norm(point[0]-point_r), (np.linalg.norm(point[0]-point_r))))
    v2 = min(np.sqrt(np.dot(np.linalg.norm(point[0]-point_r), (np.linalg.norm(point[0]-point_r)))), np.sqrt(np.dot(np.linalg.norm(point[1]-point_r), (np.linalg.norm(point[1]-point_r)))))
    if v != v2:
        point = [point[1], point[0]]
    return point[0].tolist(), point[1].tolist()

if theta != 0:
    ytre_topp_hoyre, ytre_topp_venstre = find_points_on_outer_boundary(punkt_topp_hoyre, punkt_topp_venstre)
    ytre_bunn_hoyre, ytre_bunn_venstre = find_points_on_outer_boundary(punkt_bunn_hoyre, punkt_bunn_venstre)
else:
    ytre_topp_hoyre = [150, y_topp]
    ytre_topp_venstre = [-150, y_topp]
    ytre_bunn_venstre = [-150, y_bunn]
    ytre_bunn_hoyre = [150, y_bunn]

punkter_ytre = [ytre_bunn_hoyre, ytre_topp_hoyre, ytre_topp_venstre, ytre_bunn_venstre]
print(punkter_ytre)

# indre grense
class inner_boundary:
    def __init__(self, nth_quad, punkter_ytre, punkter_indre, data, number_points_inner_boundary, index_boundary1):
        self.nth_quad = nth_quad
        self.punkter_ytre = punkter_ytre.copy()
        self.punkter_indre = punkter_indre
        self.data = data
        self.n_points_ib = number_points_inner_boundary
        self.index_boundary1 = index_boundary1

    def which_quad(self, element):
        if self.punkter_indre[element][0] > 0 and self.punkter_indre[element][1] >= 0:
            return '1st quad'
        elif self.punkter_indre[element][0] <= 0 and self.punkter_indre[element][1] > 0:
            return '2nd quad'
        elif self.punkter_indre[element][0] < 0 and self.punkter_indre[element][1] <= 0:
            return '3rd quad'
        elif self.punkter_indre[element][0] >= 0 and self.punkter_indre[element][1] < 0:
            return '4th quad'
        else:
            return None

    def get_quad_index(self, element):
        switcher = {
            '4th quad': 0,
            '1st quad': 1,
            '2nd quad': 2,
            '3rd quad': 3,
        }
        return switcher.get(inner_boundary.which_quad(self, element), None)

    def which_outer_boundary_point(self, element):
        if element == 0 or element == 3:
            return 'nedre grense'
        elif element == 1 or element == 2:
            return 'ovre grense'
        else:
            return None

    def get_indices_outer_boundary(self, element):
        switcher = {
            'nedre grense': (0, 3),
            'ovre grense': (1, 2),
        }
        index_point = switcher.get(inner_boundary.which_outer_boundary_point(self, element), None)
        return index_point

    def get_index_lowest_diff_points(self, quad_index, element):
        diff_nth = [abs(np.sqrt(
            (self.punkter_indre[element][0] - float(point[0])) ** 2 + (self.punkter_indre[element][1] - float(point[1])) ** 2)) for
                    point in self.nth_quad[quad_index]]
        sorted_diff_nth = sorted(diff_nth)
        index_lowest_diff = [diff_nth.index(sorted_diff_nth[1]), diff_nth.index(sorted_diff_nth[0])]
        return index_lowest_diff

    def calculate_intersection(self, quad_index, index_lowest_diff, indices_points_outer_boundary, element):
        a_circ = (self.nth_quad[quad_index][index_lowest_diff[1]][1] - self.nth_quad[quad_index][index_lowest_diff[0]][1]) / (
                    self.nth_quad[quad_index][index_lowest_diff[1]][0] - self.nth_quad[quad_index][index_lowest_diff[0]][0])
        b_circ = self.nth_quad[quad_index][index_lowest_diff[1]][1] - a_circ * self.nth_quad[quad_index][index_lowest_diff[1]][0]
        a_line = (self.punkter_ytre[indices_points_outer_boundary[0]][1] - self.punkter_ytre[indices_points_outer_boundary[1]][1]) / (self.punkter_ytre[indices_points_outer_boundary[0]][0] - self.punkter_ytre[indices_points_outer_boundary[1]][0])
        b_line = self.punkter_ytre[indices_points_outer_boundary[0]][1] - a_line * self.punkter_ytre[indices_points_outer_boundary[0]][0]
        x = (b_circ - b_line) / (a_line - a_circ)
        y = (b_circ * a_line - b_line * a_circ) / (a_line - a_circ)
        point = [x, y]
        return point

    def get_points_on_circular_boundary(self):
        points = []
        for i, j in enumerate(self.punkter_indre):
            quad_index = inner_boundary.get_quad_index(self, i)
            index_lowest_diff = inner_boundary.get_index_lowest_diff_points(self, quad_index, i)
            indices_points_outer_boundary = inner_boundary.get_indices_outer_boundary(self, i)
            point = inner_boundary.calculate_intersection(self, quad_index, index_lowest_diff, indices_points_outer_boundary, i)
            points.append(point)
        return points

    def get_start_quad(self, element):
        switcher = {
            '4th quad': 0,
            '1st quad': 91,
            '2nd quad': 182,
            '3rd quad': 273,
        }
        return switcher.get(inner_boundary.which_quad(self, element), None)



    def sort_boundary_points(self):
        ib = inner_boundary
        points = ib.get_points_on_circular_boundary(self)
        i_data_list = []
        for i, j in enumerate(self.punkter_indre):
            quad_index = ib.get_quad_index(self, i)
            index_lowest_diff = ib.get_index_lowest_diff_points(self, quad_index, i)
            index_lowest_diff.sort()
            i_data_list.append(self.index_boundary1 + ib.get_start_quad(self, i) + index_lowest_diff[1])
        i_data_list, points = (list(t) for t in zip(*sorted(zip(i_data_list, points))))
        self.n_points_ib = self.n_points_ib + 4
        return i_data_list, points

    def set_inner_boundary(self):
        ib = inner_boundary
        i_data_list, points = ib.sort_boundary_points(self)
        p = 0
        for i, j in enumerate(self.punkter_indre):
            # print(i_data_list[i]-self.index_boundary1, points[i])
            data.insert(i_data_list[i]+p, "         {}: ".format(0) + str(points[i][0]) + ', ' + str(points[i][1]) + '\n')
            data.insert(i_data_list[i]+self.n_points_ib+10, "        vertex 0 is temp: no" + '\n')
            p += 1
        data[self.index_boundary1-1] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>' + str(self.n_points_ib), data[self.index_boundary1-1])
        # rette opp i nummerering av punkter
        for index in range(self.n_points_ib):
            data[index_boundary1 + index] = re.sub(r'^(\s*(?:\S+\s+){0})\S+', r'\g<1>' + str(index) + ':',
                                                   data[index_boundary1 + index])[1:]
            data[index_boundary1+self.n_points_ib+10+index] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>' + str(index),
                                                         data[index_boundary1+self.n_points_ib+10+index])

n_points_boundary = 364

ib = inner_boundary(quad, punkter_ytre, punkter_indre, data, n_points_boundary, index_boundary1)
punkter_indre = ib.get_points_on_circular_boundary()
print(punkter_indre)
point_4th = punkter_indre[0]
point_1st = punkter_indre[1]
point_2nd = punkter_indre[2]
point_3rd = punkter_indre[3]


# endre boundary i kildekoden til RS2, element 1 - tunnelperiferien
# print(ib.get_quad_index(3))
# print(ib.get_index_lowest_diff_points(ib.get_quad_index(0), 0), ib.get_index_lowest_diff_points(ib.get_quad_index(1), 1), ib.get_index_lowest_diff_points(ib.get_quad_index(2), 2), ib.get_index_lowest_diff_points(ib.get_quad_index(3), 3))

ib.set_inner_boundary()
print(point_4th, point_1st, point_3rd, point_2nd)
#sette startspunkt for endringer av de tre siste boundaries
index_boundary2 = data.index("  boundary 2 start:\n")+6
index_boundary3 = data.index("  boundary 3 start:\n")+6
index_boundary4 = data.index("  boundary 4 start:\n")+6
# endre boundary i kildekoden til RS2, element 2 - ytre grense


class outer_boundary:
    def __init__(self, punkter, data, index_boundary2, vinkel, ant_pkt_ytre):
        self.punkter = punkter
        self.data = data
        self.index_boundary2 = index_boundary2
        self.ant_pkt_ytre = ant_pkt_ytre
        if vinkel != 0:
            self.del_points()
            self.set_points_outer_boundary()

    def which_line(self, element):
        if self.punkter[element][1] == -150:
            return '1st line'
        elif self.punkter[element][0] == 150:
            return '2nd line'
        elif self.punkter[element][1] == 150:
            return '3rd line'
        elif self.punkter[element][0] == -150:
            return '4th line'
        else:
            return None

    def get_boundary_index(self, element):
        switcher = {
            '1st line': 1,
            '2nd line': 2,
            '3rd line': 3,
            '4th line': 4,
        }
        return switcher.get(outer_boundary.which_line(self, element), None)

    def del_points(self):
        self.data.pop(self.index_boundary2 + 7)
        self.data.pop(self.index_boundary2 + 6)
        self.data.pop(self.index_boundary2 + 3)
        self.data.pop(self.index_boundary2 + 2)

    def sort_ob_points(self, item):
        item, self.punkter = (list(t) for t in zip(*sorted(zip(item, self.punkter), reverse=True)))
        # a, b, c, d = self.punkter[0], self.punkter[1], item[0], item[1]
        # self.punkter[0], self.punkter[1], item[0], item[1] = b, a, d, c
        return item

    def set_points_outer_boundary(self):
        placement_new_point = []
        for i in range(self.ant_pkt_ytre):
            placement_new_point.append(self.get_boundary_index(i))
        print(placement_new_point)
        print(self.punkter)
        placement_new_point = self.sort_ob_points(placement_new_point)
        print(placement_new_point)
        print(self.punkter)
        dummy = placement_new_point.copy()
        k = 1
        for i in range(0, self.ant_pkt_ytre):
            if i > 0 and placement_new_point[i] == dummy[i-1]:
                placement_new_point[i] += k
                k += 1
            else:
                k = 1
            # if placement_new_point[i + 1] >= placement_new_point[i] and i == 0:
            #     placement_new_point[i + 1] += 1
            # # elif placement_new_point[i] > placement_new_point[i+1]:
            # #     placement_new_point[i] += 1
            #
            # if i != 0:
            #     for j in range(i, self.ant_pkt_ytre, 2):
            #         if placement_new_point[j] >= placement_new_point[j-1]:
            #             placement_new_point[j] += 1
            #         if placement_new_point[j+1] >= placement_new_point[j-1]:
            #             placement_new_point[j+1] += 1
            #         if placement_new_point[j] >= placement_new_point[j-2]:
            #             placement_new_point[j] += 1
            #         if placement_new_point[j+1] >= placement_new_point[j-2]:
            #             placement_new_point[j+1] += 1
            self.data.insert(placement_new_point[i] + self.index_boundary2,  "        {}: ".format(0)+str(self.punkter[i][0])+', '+str(self.punkter[i][1])+'\n')
            print(placement_new_point)
        for index in range(len(self.data[self.index_boundary2:(self.index_boundary2+8)])):
            self.data[self.index_boundary2 + index] = re.sub(r'^(\s*(?:\S+\s+){0})\S+', r'\g<1>' + str(index) + ':',
                                                   self.data[self.index_boundary2 + index])
        return

ant_pkt_ytre = 4
outer_boundary(punkter_ytre, data, index_boundary2, vinkel, ant_pkt_ytre)


# endre boundary (svakhetssone) i kildekoden til RS2, element 3 - bunn
def inner_points_cleanup():
    k = [3, 2]
    l = [[0, 3], [1, 2]]
    for i in range(2):
        v3 = np.sqrt(np.dot(np.linalg.norm(np.array(punkter_ytre[i])-np.array(punkter_indre[i])), (np.linalg.norm(np.array(punkter_ytre[i])-np.array(punkter_indre[i])))))
        v4 = np.sqrt(np.dot(np.linalg.norm(np.array(punkter_ytre[i])-np.array(punkter_indre[i+k[i]])), (np.linalg.norm(np.array(punkter_ytre[i])-np.array(punkter_indre[i+k[i]])))))
        if v3 > v4:
            x = punkter_indre.copy()
            punkter_indre[l[i][0]] = x[l[i][1]]
            punkter_indre[l[i][1]] = x[l[i][0]]


inner_points_cleanup()
data[index_boundary3] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(punkter_ytre[3][0])+',', data[index_boundary3])
data[index_boundary3] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(punkter_ytre[3][1]), data[index_boundary3])

data[index_boundary3+1] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(punkter_indre[3][0])+',', data[index_boundary3+1])
data[index_boundary3+1] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(punkter_indre[3][1]), data[index_boundary3+1])

data[index_boundary3+2] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(punkter_indre[0][0])+',', data[index_boundary3+2])
data[index_boundary3+2] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(punkter_indre[0][1]), data[index_boundary3+2])

data[index_boundary3+3] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(punkter_ytre[0][0])+',', data[index_boundary3+3])
data[index_boundary3+3] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(punkter_ytre[0][1]), data[index_boundary3+3])

# endre boundary (svakhetssone) i kildekoden til RS2, element 4 - topp
data[index_boundary4] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(punkter_ytre[1][0])+',', data[index_boundary4])
data[index_boundary4] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(punkter_ytre[1][1]), data[index_boundary4])

data[index_boundary4+1] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(punkter_indre[1][0])+',', data[index_boundary4+1])
data[index_boundary4+1] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(punkter_indre[1][1]), data[index_boundary4+1])

data[index_boundary4+2] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(punkter_indre[2][0])+',', data[index_boundary4+2])
data[index_boundary4+2] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(punkter_indre[2][1]), data[index_boundary4+2])

data[index_boundary4+3] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(punkter_ytre[2][0])+',', data[index_boundary4+3])
data[index_boundary4+3] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(punkter_ytre[2][1]), data[index_boundary4+3])


# endre materials mesh i kildekoden til RS2, element 1
data[index_materialMesh+9] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(point_3rd[0])+',', data[index_materialMesh+9])
data[index_materialMesh+9] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(point_3rd[1]), data[index_materialMesh+9])
# data[index_materialMesh+10] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\1 '+str(point_3rd[0])+',', data[index_materialMesh+10])
# data[index_materialMesh+10] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\1 '+str(point_3rd[1]), data[index_materialMesh+10])
data[index_materialMesh+11] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(point_4th[0])+',', data[index_materialMesh+11])
data[index_materialMesh+11] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(point_4th[1]), data[index_materialMesh+11])

# endre materials mesh i kildekoden til RS2, element 2
data[index_materialMesh+18] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(ytre_topp_venstre[0])+',', data[index_materialMesh+18])
data[index_materialMesh+18] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(ytre_topp_venstre[1]), data[index_materialMesh+18])
data[index_materialMesh+19] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(ytre_bunn_venstre[0])+',', data[index_materialMesh+19])
data[index_materialMesh+19] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(ytre_bunn_venstre[1]), data[index_materialMesh+19])


# endre materials mesh i kildekoden til RS2, element 3
data[index_materialMesh+27] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(point_3rd[0])+',', data[index_materialMesh+27])
data[index_materialMesh+27] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(point_3rd[1]), data[index_materialMesh+27])
data[index_materialMesh+28] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(point_1st[0])+',', data[index_materialMesh+28])
data[index_materialMesh+28] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(point_1st[1]), data[index_materialMesh+28])
data[index_materialMesh+29] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(point_2nd[0])+',', data[index_materialMesh+29])
data[index_materialMesh+29] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(point_2nd[1]), data[index_materialMesh+29])

# endre materials mesh i kildekoden til RS2, element 5
data[index_materialMesh+45] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(point_1st[0])+',', data[index_materialMesh+45])
data[index_materialMesh+45] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(point_1st[1]), data[index_materialMesh+45])
data[index_materialMesh+47] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(point_2nd[0])+',', data[index_materialMesh+47])
data[index_materialMesh+47] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(point_2nd[1]), data[index_materialMesh+47])

# endre materials mesh i kildekoden til RS2, element 6
data[index_materialMesh+54] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(ytre_topp_hoyre[0])+',', data[index_materialMesh+54])
data[index_materialMesh+54] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(ytre_topp_hoyre[1]), data[index_materialMesh+54])
data[index_materialMesh+55] = re.sub(r'^(\s*(?:\S+\s+){1})\S+', r'\g<1>'+str(ytre_bunn_hoyre[0])+',', data[index_materialMesh+55])
data[index_materialMesh+55] = re.sub(r'^(\s*(?:\S+\s+){2})\S+', r'\g<1>'+str(ytre_bunn_hoyre[1]), data[index_materialMesh+55])
# and write everything back
with open(path_of_RS2_file, 'w') as file:
    file.writelines(data)
